<!DOCTYPE html>

<html lang="fr">
<head>
 <link rel="manifest" href="/manifest.json">
<link rel="apple-touch-icon" href="/hs/apple-touch-icon.png">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Compteur Heures & Paie">
<meta name="theme-color" content="#4FB3C2">
<meta charset="UTF-8">
<title>Simulateur d'heures mensualis√©</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
.kitsune-btn {
  flex: 1;
  padding: 8px 16px;
  border-radius: 20px;
  border: none;
  background: linear-gradient(135deg, #FF8C42, #e06a1a);
  color: #fff;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(255,140,66,0.35);
  transition: transform 0.15s, box-shadow 0.15s;
}
.kitsune-btn:hover { transform: scale(1.02); box-shadow: 0 4px 16px rgba(255,140,66,0.55); }
.kitsune-btn:active { transform: scale(0.97); }
.top-nav-bar {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  margin-bottom: 20px;
  padding-top: env(safe-area-inset-top);
}
.top-nav-bar .menu-btn { flex: 1; margin: 0; }
.menu-btn {
  margin-top: 8px;
  margin-bottom: 20px;
  padding: 8px 16px;
  border-radius: 20px;
  border: none;
  background: rgba(255,255,255,0.85);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
}
.topbar {
  position: sticky;
  top: 0;
  z-index: 2000;
  background: var(--bg);
  padding: calc(env(safe-area-inset-top) + 10px) 15px 10px;
}
:root {
  --bg: #0f1115;
  --card: #1c1f26;
  --text: #e6e6e6;
  --muted: #9aa0a6;
  --accent: #4f8cff;
  --danger: #c0392b;
  --success: #2ecc71;
  --geo-active: #00c896;
  --geo-inactive: #555;
}
#versionBadge {
  position: fixed;
  bottom: calc(env(safe-area-inset-bottom) + 14px);
  right: calc(env(safe-area-inset-right) + 14px);
  font-size: 11px;
  opacity: 0.55;
  color: #9aa0a6;
  z-index: 99999;
  user-select: none;
  pointer-events: none;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
}
.main { padding: 15px; }
h1, h2, h3 { text-align: center; }
button {
  width: 100%;
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: white;
  font-size: 15px;
  margin-top: 6px;
}
button.secondary { background: #2a2f3a; }
button.danger { background: var(--danger); }
input, select {
  width: 100%;
  padding: 8px;
  margin-top: 6px;
  background: #262a33;
  color: var(--text);
  border: 1px solid #333;
  border-radius: 6px;
  box-sizing: border-box;
}
.card {
  background: var(--card);
  padding: 15px;
  border-radius: 12px;
  margin-top: 15px;
}
.calendar {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
}
.weekday { text-align: center; font-weight: bold; font-size: 12px; }
.day {
  background: #262a33;
  border-radius: 8px;
  padding: 6px;
  text-align: center;
  cursor: pointer;
  min-height: 60px;
  transition: border 0.2s ease, opacity 0.2s ease, transform 0.1s ease;
}
.day.today {
  border: 2px solid #ff9500 !important;
  opacity: 1 !important;
  background: #2e2a1f;
  box-shadow: 0 0 0 2px rgba(255,149,0,0.4);
  transform: scale(1.03);
  z-index: 2;
}
.day.locked { opacity: .4; cursor: not-allowed; }
.day.after-closing { border: 1px dashed #4f8cff; opacity: 0.75; }
.day.after-closing.today { opacity: 1 !important; border-style: solid; }
.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 4000;
  opacity: 0;
  pointer-events: none;
  transform: translateY(10px);
  transition: opacity .2s ease, transform .2s ease;
}
.modal.open { opacity: 1; pointer-events: auto; transform: translateY(0); }
.modal-content {
  background: var(--card);
  border-radius: 16px;
  padding: 20px;
  width: 90%;
  max-width: 420px;
  max-height: 85vh;
  overflow-y: auto;
}
.blur { filter: blur(8px); }
.badge {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
}
.badge.ok { background: #1b5e20; }
.badge.file { background: #283593; }
input[type="month"] {
  text-align: center;
  padding-right: 0;
  appearance: none;
  -webkit-appearance: none;
}
input[type="number"] {
  text-align: center;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: textfield;
  padding-left: 0;
  padding-right: 0;
}

/* =========================================
   G√âOLOCALISATION ‚Äì STYLES SP√âCIFIQUES
========================================= */

/* Pastille de statut g√©o */
.geo-status-dot {
  display: inline-block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--geo-inactive);
  margin-right: 6px;
  vertical-align: middle;
  transition: background 0.4s;
}
.geo-status-dot.active {
  background: var(--geo-active);
  box-shadow: 0 0 6px var(--geo-active);
  animation: geo-pulse 1.8s ease-in-out infinite;
}
@keyframes geo-pulse {
  0%, 100% { box-shadow: 0 0 4px var(--geo-active); }
  50% { box-shadow: 0 0 14px var(--geo-active); }
}

/* Carte de statut pointage */
.geo-card {
  background: #12161e;
  border: 1px solid #2a3040;
  border-radius: 12px;
  padding: 15px;
  margin-top: 15px;
}
.geo-card.pointed-in {
  border-color: var(--geo-active);
  background: #0a1f18;
}

/* Timeline des pointages du jour */
.punch-timeline {
  margin-top: 10px;
  padding-left: 10px;
  border-left: 2px solid #333;
}
.punch-entry {
  position: relative;
  padding: 6px 0 6px 16px;
  font-size: 13px;
  color: var(--muted);
}
.punch-entry::before {
  content: '';
  position: absolute;
  left: -5px;
  top: 50%;
  transform: translateY(-50%);
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #4f8cff;
}
.punch-entry.in::before { background: var(--geo-active); }
.punch-entry.out::before { background: #ff6b6b; }
.punch-entry .punch-hours {
  font-weight: bold;
  color: var(--text);
  margin-left: 6px;
}

/* Bouton pointage principal */
.punch-btn {
  font-size: 18px;
  font-weight: bold;
  padding: 14px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
  width: 100%;
  margin-top: 10px;
}
.punch-btn.start {
  background: linear-gradient(135deg, #00c896, #009966);
  color: white;
  box-shadow: 0 4px 16px rgba(0, 200, 150, 0.3);
}
.punch-btn.stop {
  background: linear-gradient(135deg, #ff6b6b, #cc2200);
  color: white;
  box-shadow: 0 4px 16px rgba(255, 80, 80, 0.3);
}
.punch-btn:active { transform: scale(0.97); }

/* Zone configuration g√©o */
.geo-config-row {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-top: 10px;
}
.geo-config-row label {
  font-size: 13px;
  color: var(--muted);
  min-width: 130px;
}
.geo-config-row input {
  flex: 1;
  margin-top: 0;
}

/* Radar anim√© quand surveillance active */
.geo-radar {
  display: none;
  text-align: center;
  margin-top: 8px;
  font-size: 12px;
  color: var(--geo-active);
  animation: radar-blink 2s ease-in-out infinite;
}
.geo-radar.visible { display: block; }
@keyframes radar-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* Badge distance */
.geo-distance-badge {
  display: inline-block;
  background: #1c2535;
  border: 1px solid #2a3a55;
  border-radius: 20px;
  padding: 3px 10px;
  font-size: 12px;
  color: var(--muted);
  margin-top: 6px;
}
.geo-distance-badge.near { border-color: var(--geo-active); color: var(--geo-active); }
.geo-distance-badge.far { border-color: #ff6b6b; color: #ff9999; }

/* Toast notification */
.geo-toast {
  position: fixed;
  top: calc(env(safe-area-inset-top) + 80px);
  left: 50%;
  transform: translateX(-50%) translateY(-200px);
  background: #1c1f26;
  border: 1px solid var(--geo-active);
  color: var(--text);
  border-radius: 14px;
  padding: 14px 20px;
  max-width: 340px;
  width: 90%;
  z-index: 9999;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  transition: transform 0.35s cubic-bezier(0.34,1.56,0.64,1);
  font-size: 14px;
}
.geo-toast.show { transform: translateX(-50%) translateY(0); }
.geo-toast .geo-toast-title {
  font-weight: bold;
  font-size: 15px;
  margin-bottom: 6px;
}
.geo-toast .geo-toast-actions {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}
.geo-toast .geo-toast-actions button {
  flex: 1;
  padding: 8px;
  font-size: 13px;
  margin: 0;
  border-radius: 8px;
}
.geo-toast .btn-confirm {
  background: var(--geo-active);
  color: #000;
  font-weight: bold;
}
.geo-toast .btn-dismiss {
  background: #2a2f3a;
  color: var(--muted);
}

</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</head>
<body>
<div class="top-nav-bar">
  <button class="menu-btn" onclick="goMenu()">‚¨Ö Retour au menu</button>
  <button class="kitsune-btn" onclick="window.location.href='../fox/index.html'" title="Ouvrir FOX Engine">ü¶ä Kitsune</button>
</div>

<!-- ==================== MODALES SYST√àME ==================== -->

<div class="modal" id="debugGate">
  <div class="modal-content">
    <h3>üß™ Acc√®s debug s√©curis√©</h3>
    <p style="font-size:14px">Avant toute intervention, un <b>test de crash</b> est obligatoire.</p>
    <input type="password" id="debugCode" placeholder="Code requis (1234)">
    <button class="danger" onclick="validateDebugAccess()">üí• Tester le crash maintenant</button>
    <button class="secondary" onclick="closeDebugGate()">Annuler</button>
  </div>
</div>

<div class="modal" id="recoveryModal">
  <div class="modal-content">
    <h2>üõ†Ô∏è Mode r√©cup√©ration</h2>
    <h3>üì∏ Snapshots disponibles</h3>
    <div id="snapshotList"></div>
    <p style="font-size:14px">L'application a d√©tect√© un probl√®me lors du dernier d√©marrage.</p>
    <button onclick="recoverAuto()">üîÑ R√©paration automatique</button>
    <button class="secondary" onclick="recoverSoftReset()">‚ôªÔ∏è R√©initialiser l'interface</button>
    <button class="danger" onclick="recoverFactory()">üß® R√©initialisation compl√®te</button>
    <p style="font-size:12px;color:#aaa;margin-top:10px">‚ö†Ô∏è La r√©initialisation compl√®te supprime les donn√©es locales.</p>
  </div>
</div>

<!-- ==================== TOAST G√âOLOCALISATION ==================== -->

<div class="geo-toast" id="geoToast">
  <div class="geo-toast-title" id="geoToastTitle">üìç Tu arrives au travail</div>
  <div id="geoToastMsg" style="color:var(--muted);font-size:13px"></div>
  <div class="geo-toast-actions">
    <button class="btn-confirm" id="geoToastConfirm" onclick="confirmGeoAction()">‚úÖ D√©marrer</button>
    <button class="btn-dismiss" onclick="dismissGeoToast()">Plus tard</button>
  </div>
</div>

<!-- ==================== TOPBAR ==================== -->

<div class="topbar">
  <button onclick="openTutorial()">‚ùì Tutoriel</button>
</div>

<div class="main">

  <h1>‚è±Ô∏è Heures suppl√©mentaires</h1>
  <p style="text-align:center;font-size:14px;color:#9aa0a6;margin-top:-10px;">
    Suivi pr√©cis des heures suppl√©mentaires bas√© sur la
    <b>logique r√©elle de paie mensuelle</b>
    (cl√¥ture mensuelle + report automatique)
  </p>

  <div class="card">
    <label>Mois suivi</label>
    <input type="month" id="monthPicker">
    <label>Jour de cl√¥ture mensuelle</label>
    <input type="date" id="closingDate">
  </div>

  <div class="calendar card" id="calendar"></div>

  <!-- ==================== CARTE POINTAGE G√âOLOCALIS√â ==================== -->

  <div class="geo-card" id="geoCard">
    <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px">
      <div>
        <span class="geo-status-dot" id="geoDot"></span>
        <b style="font-size:15px">Pointage g√©olocalis√©</b>
      </div>
      <span id="geoStatusLabel" style="font-size:12px;color:var(--muted)">Inactif</span>
    </div>

```
<!-- Statut distance temps r√©el -->
<div id="geoDistanceBlock" style="margin-top:8px;display:none">
  <span class="geo-distance-badge" id="geoDistanceBadge">üì° Calcul‚Ä¶</span>
</div>

<!-- Radar animation -->
<div class="geo-radar" id="geoRadar">üì° Surveillance en cours‚Ä¶</div>

<!-- Bouton pointage manuel -->
<button class="punch-btn start" id="punchBtn" onclick="manualPunch()">
  ‚ñ∂ Pointer l'arriv√©e
</button>

<!-- Timeline du jour -->
<div class="punch-timeline" id="punchTimeline"></div>

<!-- R√©sum√© heures du jour -->
<div id="geoTodaySummary" style="font-size:13px;color:var(--muted);margin-top:8px;display:none">
  ‚è± Aujourd'hui : <b id="geoTodayHours">0.00 h</b>
</div>

<!-- Bouton config -->
<button class="secondary" style="margin-top:12px;font-size:13px" onclick="toggleGeoConfig()">
  ‚öôÔ∏è Configuration du pointage
</button>

<!-- Zone de configuration d√©pliable -->
<div id="geoConfigPanel" style="display:none;margin-top:12px">
  <hr style="border-color:#2a3040;margin-bottom:12px">

  <!-- Lieu de travail -->
  <div style="font-size:13px;color:var(--muted);margin-bottom:8px">
    <b style="color:var(--text)">üìç Lieu de travail</b>
  </div>
  <div id="geoSavedLocation" style="font-size:12px;color:var(--muted);margin-bottom:8px"></div>

  <button onclick="captureWorkLocation()" style="background:#1b3a2a;color:var(--geo-active);border:1px solid var(--geo-active);font-size:13px">
    üìå Enregistrer ma position actuelle comme lieu de travail
  </button>

  <button class="secondary" style="font-size:13px;margin-top:6px" onclick="clearWorkLocation()">
    üóëÔ∏è Supprimer le lieu enregistr√©
  </button>

  <hr style="border-color:#2a3040;margin:12px 0">

  <!-- Rayon de d√©tection -->
  <div class="geo-config-row">
    <label>Rayon de d√©tection</label>
    <input type="number" id="geoRadius" value="200" min="50" max="2000" step="50">
    <span style="font-size:12px;color:var(--muted);white-space:nowrap">m</span>
  </div>

  <div style="font-size:11px;color:var(--muted);margin-top:4px;line-height:1.4">
    ‚ÑπÔ∏è D√®s que tu entres dans cette zone, une notification te propose de pointer ‚Äî quelle que soit l'heure. Tu restes libre de valider ou ignorer.
  </div>

  <hr style="border-color:#2a3040;margin:12px 0">

  <!-- Activation de la surveillance -->
  <label style="display:flex;align-items:center;gap:10px;cursor:pointer;font-size:14px">
    <input type="checkbox" id="geoWatchToggle" style="width:auto;margin:0">
    Activer la surveillance automatique
  </label>
  <div style="font-size:11px;color:var(--muted);margin-top:4px">
    N√©cessite que l'application reste ouverte. Aucune donn√©e n'est envoy√©e √† l'ext√©rieur.
  </div>

  <button onclick="saveGeoConfig()" style="margin-top:12px;background:#1a2a3a;border:1px solid var(--accent);font-size:13px">
    üíæ Enregistrer la configuration
  </button>
</div>
```

  </div>

  <!-- ==================== RECAP ==================== -->

  <div class="card">
    <h3>R√©capitulatif</h3>
    <p>Report pr√©c√©dent : <b id="prevCarry">0.00</b> h</p>
    <p>Total p√©riode : <b id="totalMonth">0.00</b> h</p>
    <p>Heures √† 25 % : <b id="hours25">0.00</b> h</p>
    <p>Heures √† 50 % : <b id="hours50">0.00</b> h</p>
    <p style="font-size:12px;color:#aaa;margin-top:8px">
      ‚ÑπÔ∏è Calcul bas√© sur une hypoth√®se standard : 25% jusqu'√† 8h hebdomadaires, puis 50%.
      Peut varier selon la convention collective.
    </p>
    <p>Heures pay√©es : <input type="number" id="paidHours" step="0.25"></p>
    <p>Reliquat report√© : <b id="carryOver">0.00</b> h</p>
  </div>

  <div class="card">
    <h3>üí∞ Valeur ‚Ç¨</h3>
    <div id="euroBox" class="blur">
      <label>Taux horaire (‚Ç¨)</label>
      <input type="number" id="rate">
      <label>Coef 25 %</label>
      <input type="number" id="coef25">
      <label>Coef 50 %</label>
      <input type="number" id="coef50">
      <label>Coef brut ‚Üí net</label>
      <input type="number" id="coefNet">
      <p><b id="euroResult">0.00 ‚Ç¨</b></p>
      <p id="euroDetail" style="font-size:12px;color:#aaa;margin-top:8px"></p>
      <p style="font-size:12px;color:#9aa0a6;margin-top:10px;line-height:1.4">
        ‚ö†Ô∏è Les <b>taux</b> et <b>coefficients</b> utilis√©s sont fournis √† titre <b>strictement indicatif</b>.<br>
        <b>Seul le bulletin de paie fait foi.</b>
      </p>
    </div>
    <input type="password" id="unlockCode" placeholder="Code (1234)">
    <button onclick="unlockEuro()">D√©verrouiller</button>
  </div>

<button class="secondary" onclick="toggleChangeCode()">üîÅ Changer le code</button>

  <div id="changeCodeBox" style="display:none;margin-top:10px">
    <input type="password" id="oldCode" placeholder="Ancien code">
    <input type="password" id="newCode" placeholder="Nouveau code (4 chiffres min)">
    <input type="password" id="confirmCode" placeholder="Confirmer le code">
    <button class="danger" onclick="changeCode()">Valider le nouveau code</button>
  </div>

  <div class="card">
    <span class="badge ok">üü¢ Sauvegarde locale auto</span>
    <span class="badge file">üë§ Usage personnel ‚Äì outil indicatif</span>
    <span class="badge file">üíæ Dernier fichier : <span id="fileDate">‚Äî</span></span>
    <button onclick="exportJSON()">üíæ Sauvegarde dans un fichier</button>
    <input type="file" id="importFile" accept=".json" style="display:none">
    <button class="secondary" onclick="document.getElementById('importFile').click()">üì• Importer une sauvegarde</button>
    <button onclick="exportMonthlyPDF()">üìÑ PDF mensuel d√©taill√©</button>
    <button onclick="exportAnnualPDF()">üìï PDF annuel r√©capitulatif</button>
  </div>

  <!-- ==================== MODALES ==================== -->

  <div class="modal" id="hoursModal">
    <div class="modal-content">
      <h3>‚è±Ô∏è Ajouter des heures</h3>
      <div id="hoursChoices"></div>
      <label>Saisie manuelle</label>
      <input type="number" id="manualHours" step="0.25">
      <button onclick="confirmManual()">Valider</button>
      <button class="danger" onclick="deleteDayHours()">üóëÔ∏è Supprimer les heures du jour</button>
      <button class="secondary" onclick="closeHours()">Annuler</button>
    </div>
  </div>

  <div class="modal" id="tutorialModal">
    <div class="modal-content" style="max-width:700px;max-height:80vh;overflow:auto;">
      <h2>üìò Tutoriel ‚Äì Suivi des heures suppl√©mentaires</h2>
      <h3>1Ô∏è‚É£ Principe g√©n√©ral</h3>
      <p>Cet outil permet de suivre les heures suppl√©mentaires dans le cadre d'une <b>paie mensuelle</b>, avec report automatique des reliquats.</p>
      <h3>2Ô∏è‚É£ Saisie des heures</h3>
      <p>Clique sur un jour pour saisir manuellement tes heures, ou utilise le <b>pointage g√©olocalis√©</b> pour une saisie automatique depuis le terrain.</p>
      <h3>3Ô∏è‚É£ Pointage g√©olocalis√©</h3>
      <p>Configure une fois ton lieu de travail et tes horaires. L'app te propose de pointer d√®s que tu arrives dans la zone ‚Äî <b>tu valides toujours manuellement</b>. Aucune donn√©e ne sort de ton appareil.</p>
      <h3>4Ô∏è‚É£ Cl√¥ture mensuelle</h3>
      <p>Le jour de cl√¥ture d√©finit la fin de la p√©riode de paie. Les heures apr√®s cette date sont automatiquement report√©es.</p>
      <h3>5Ô∏è‚É£ Zone ‚Ç¨</h3>
      <p>Les montants sont flout√©s par d√©faut et prot√©g√©s par code.</p>
      <button class="secondary" onclick="closeTutorial()">Fermer</button>
    </div>
  </div>

  <div class="modal" id="legalModal">
    <div class="modal-content">
      <h2>‚ö†Ô∏è Avertissement important</h2>
      <p style="font-size:14px">
        Cet outil est un <b>simulateur personnel</b>.<br><br>
        Les calculs sont indicatifs et peuvent diff√©rer de votre bulletin de paie r√©el.<br><br>
        <b>Seuls les documents de l'employeur font foi.</b>
      </p>
      <button onclick="acceptLegal()">J'ai compris</button>
    </div>
  </div>

  <div class="modal" id="onboardingModal">
    <div class="modal-content">
      <h2>üëã Bienvenue</h2>
      <ol style="font-size:14px">
        <li>S√©lectionne le mois suivi</li>
        <li>D√©finis le dimanche de cl√¥ture</li>
        <li>Clique sur un jour pour ajouter des heures</li>
        <li>Configure le pointage g√©olocalis√© (optionnel)</li>
      </ol>
      <button onclick="closeOnboarding()">Commencer</button>
    </div>
  </div>

  <!-- ==================== NOTICE ==================== -->

  <div class="card" style="font-size:13px;color:#aaa">
    <h3>üìò Notice utilisateur</h3>
    <p>Cet outil est destin√© au suivi personnel des heures suppl√©mentaires dans le cadre d'une r√©mun√©ration mensuelle.</p>
    <p>Les calculs sont indicatifs et reposent sur les principes g√©n√©raux :</p>
    <ul>
      <li>Code du travail</li>
      <li>Convention collective du commerce de gros (IDCC 573)</li>
    </ul>
    <p>‚ö†Ô∏è En cas de litige, seuls les bulletins de paie et documents officiels de l'employeur font foi.</p>
  </div>
  <div class="card" style="font-size:12px;color:#9aa0a6;line-height:1.5">
    <b>‚ö†Ô∏è Responsabilit√© et limites</b><br><br>
    Les donn√©es saisies dans ce simulateur sont renseign√©es <b>sous la seule responsabilit√© de l'utilisateur</b>.<br><br>
    Les r√©sultats affich√©s sont fournis √† titre indicatif. <b>Seuls les documents √©tablis par l'employeur et le droit applicable font foi.</b>
  </div>

</div><!-- /main -->

<footer id="debugTrigger" style="margin-top:30px;text-align:center;font-size:12px;color:#777;cursor:pointer">
  ¬© C. Anthony<br>
  Outil indicatif ‚Äì ne constitue pas un bulletin de paie
</footer>
<div id="versionBadge"></div>

<!-- ==================== JAVASCRIPT ==================== -->

<script>
/* =======================
   CONSTANTES GLOBALES
======================= */
const STORAGE_PREFIX = "CA_HS_TRACKER_V1";
const APP_VERSION    = "1.4.0"; // +g√©olocalisation
const SNAP_KEY       = `${STORAGE_PREFIX}_SNAPSHOTS`;
const SNAP_LIMIT     = 5;
const DATA_VERSION   = "1.0";
const GEO_KEY        = `${STORAGE_PREFIX}_GEO_CONFIG`;
const GEO_PUNCHES    = `${STORAGE_PREFIX}_GEO_PUNCHES`;

/* =======================
   MODE R√âCUP√âRATION
======================= */
const RECOVERY_ACTIVE = localStorage.getItem("CA_HS_RECOVERY_MODE") === "1";
if(RECOVERY_ACTIVE) console.warn("üõ†Ô∏è MODE R√âCUP√âRATION ACTIV√â");

/* =======================
   DONN√âES PRINCIPALES
======================= */
let DATA = {};
let SETTINGS = JSON.parse(localStorage.getItem(kSettings()) || "{}");
let ALL_DATA = {};
let currentKey = "", currentDay = null, unlocked = false;

/* =======================
   G√âOLOCALISATION ‚Äì √âTAT
======================= */
let GEO_CONFIG = JSON.parse(localStorage.getItem(GEO_KEY) || "{}");
// GEO_CONFIG : { lat, lng, radius, watchEnabled }

let GEO_PUNCHES_DATA = JSON.parse(localStorage.getItem(GEO_PUNCHES) || "{}");
// GEO_PUNCHES_DATA : { "2025-02-20": [ {type:"in"|"out", ts: ISO}, ... ] }

let geoWatchId        = null;   // ID watchPosition
let geoCheckInterval  = null;   // Polling fallback
let geoIsPunchedIn    = false;  // √©tat actuel de la journ√©e
let geoLastDistance   = null;   // derni√®re distance calcul√©e (m)
let geoToastPending   = null;   // "in" | "out" | null ‚Äì action propos√©e
let geoToastTimer     = null;   // setTimeout pour auto-dismiss

/* =======================
   HELPERS CL√â STOCKAGE
======================= */
function kData(year)    { return `${STORAGE_PREFIX}_DATA_${year}`; }
function kSettings()    { return `${STORAGE_PREFIX}_SETTINGS`; }
function kCode()        { return `${STORAGE_PREFIX}_CODE_HASH`; }
function kIndex()       { return `${STORAGE_PREFIX}_INDEX`; }
function getYearFromMonth(key) { return key.split("-")[0]; }

/* =======================
   PR√âCHARGEMENT ANN√âES
======================= */
(function preloadAllYears(){
  const index = JSON.parse(localStorage.getItem(kIndex()) || "[]");
  index.forEach(year => {
    try { ALL_DATA[year] = loadYearData(year); }
    catch(e) { console.warn("‚ö†Ô∏è Impossible de charger", year); ALL_DATA[year] = {}; }
  });
})();

/* =======================
   AUTO-REFRESH PWA
======================= */
(function autoRefreshPWA(){
  const key  = "CA_APP_VERSION";
  const last = localStorage.getItem(key);
  if(last !== APP_VERSION){
    localStorage.setItem(key, APP_VERSION);
    if(!sessionStorage.getItem("CA_REFRESHED")){
      sessionStorage.setItem("CA_REFRESHED","1");
      location.reload();
    }
  }
})();

/* =======================
   MIGRATION DONN√âES
======================= */
(function migrateLocalDataIfNeeded(){
  const stored = localStorage.getItem("CA_DATA_VERSION");
  if(stored === DATA_VERSION) return;
  Object.entries(ALL_DATA).forEach(([year, yearData]) => {
    Object.values(yearData).forEach(month => {
      if(typeof month.closing !== "number") month.closing = null;
      if(typeof month.locked !== "boolean") month.locked = false;
    });
    saveYearData(year, yearData);
  });
  localStorage.setItem("CA_DATA_VERSION", DATA_VERSION);
})();

/* =======================
   INIT PAGE
======================= */
window.addEventListener("load", () => {
  const v = document.getElementById("versionBadge");
  if(v) v.textContent = "v" + APP_VERSION;

  if(RECOVERY_ACTIVE){ openRecovery(); return; }
  if(!localStorage.getItem("LEGAL_OK")){
    document.getElementById("legalModal").classList.add("open");
    return;
  }
  if(!localStorage.getItem("ONBOARDING_DONE")){
    document.getElementById("onboardingModal").classList.add("open");
  }

  // Restaurer √©tat g√©o depuis config sauvegard√©e
  loadGeoConfig();
});

/* =======================
   CALENDRIER / MOIS
======================= */
const monthPicker  = document.getElementById("monthPicker");
const closingDate  = document.getElementById("closingDate");
const paidInput    = document.getElementById("paidHours");

monthPicker.value  = new Date().toISOString().slice(0,7);
monthPicker.onchange = loadMonth;
paidInput.oninput  = () => {
  if(!DATA || !DATA[currentKey]) return;
  DATA[currentKey].paid = parseFloat(paidInput.value) || 0;
  save();
  recalc();
};

function getLastSunday(year, monthIndex){
  const lastDay = new Date(year, monthIndex + 1, 0);
  const day = lastDay.getDay();
  const diff = day === 0 ? 0 : day;
  lastDay.setDate(lastDay.getDate() - diff);
  return lastDay.getDate();
}

function getPeriodBounds(monthKey){
  if(!monthKey || typeof monthKey !== "string"){
    const now = new Date();
    return { start: new Date(now.getFullYear(), now.getMonth(), 1),
             end:   new Date(now.getFullYear(), now.getMonth()+1, 0) };
  }
  const [y, m] = monthKey.split("-").map(Number);
  if(!y || !m) return { start: new Date(y||1970,(m||1)-1,1), end: new Date(y||1970,m||1,0) };

  const year      = String(y);
  const yearData  = ALL_DATA[year];
  const currentM  = yearData?.[monthKey];
  if(!currentM) return { start: new Date(y,m-1,1), end: new Date(y,m,0) };

  const prevDate  = new Date(y, m-2, 1);
  const prevKey   = prevDate.getFullYear() + "-" + String(prevDate.getMonth()+1).padStart(2,"0");
  const prevYData = ALL_DATA[String(prevDate.getFullYear())] || {};
  const prevMonth = prevYData[prevKey];

  let start;
  if(prevMonth && typeof prevMonth.closing === "number"){
    start = new Date(prevDate.getFullYear(), prevDate.getMonth(), prevMonth.closing+1);
  } else {
    start = new Date(y, m-1, 1);
  }

  let closing = currentM.closing;
  if(typeof closing !== "number" || new Date(y,m-1,closing).getDay() !== 0){
    closing = getLastSunday(y, m-1);
  }
  return { start, end: new Date(y, m-1, closing) };
}

function loadMonth(){
  currentKey = monthPicker.value;
  const year = getYearFromMonth(currentKey);
  registerYear(year);
  if(!ALL_DATA[year]) ALL_DATA[year] = loadYearData(year);
  DATA = ALL_DATA[year];
  const [y, m] = currentKey.split("-").map(Number);
  let needSave = false;
  if(!DATA[currentKey]){
    DATA[currentKey] = { days:{}, paid:0, carry:0, closing:getLastSunday(y,m-1), locked:false };
    needSave = true;
  }
  {
    const lastDay = new Date(y,m,0).getDate();
    const closing = DATA[currentKey].closing;
    if(!closing || closing>lastDay || new Date(y,m-1,closing).getDay()!==0){
      DATA[currentKey].closing = getLastSunday(y,m-1);
      needSave = true;
    }
  }
  paidInput.value = DATA[currentKey].paid || 0;
  setClosingLimits();
  syncClosingDate();
  renderCalendar();
  recalcCascade();
  recalc();
  scrollToToday();
  renderGeoTimeline();
  if(needSave) save();
}

function setClosingLimits(){
  const [y,m] = currentKey.split("-").map(Number);
  const lastDay = new Date(y,m,0).getDate();
  closingDate.min = `${y}-${String(m).padStart(2,"0")}-01`;
  closingDate.max = `${y}-${String(m).padStart(2,"0")}-${lastDay}`;
}

function syncClosingDate(){
  if(!DATA[currentKey]) return;
  const [y,m] = currentKey.split("-").map(Number);
  const day = DATA[currentKey].closing || 31;
  closingDate.value = `${y}-${String(m).padStart(2,"0")}-${String(day).padStart(2,"0")}`;
}

closingDate.oninput = () => {
  if(!closingDate.value) return;
  const selected = new Date(closingDate.value);
  const [y,m]    = currentKey.split("-").map(Number);
  if(selected.getFullYear()!==y || selected.getMonth()+1!==m){
    alert("‚õî La date doit √™tre dans le mois s√©lectionn√©");
    syncClosingDate(); return;
  }
  if(selected.getDay()!==0){
    alert("‚õî La cl√¥ture doit obligatoirement √™tre un dimanche");
    syncClosingDate(); return;
  }
  DATA[currentKey].closing = selected.getDate();
  save(); renderCalendar(); recalc();
};

closingDate.addEventListener("blur", () => {
  const cal = document.getElementById("calendar");
  if(!cal) return;
  cal.style.display = "none";
  cal.offsetHeight;
  cal.style.display = "grid";
});

function scrollToToday(){
  const today = new Date().toISOString().slice(0,7);
  if(currentKey !== today) return;
  const el = document.getElementById("todayCell");
  if(el) el.scrollIntoView({ behavior:"smooth", block:"center" });
}

/* =======================
   RENDU CALENDRIER
======================= */
function renderCalendar(){
  const cal   = document.getElementById("calendar");
  cal.innerHTML = "";
  const weekDays = ["Lun","Mar","Mer","Jeu","Ven","Sam","Dim"];
  weekDays.forEach(d => {
    const w = document.createElement("div");
    w.className = "weekday";
    w.textContent = d;
    cal.appendChild(w);
  });
  const [y,m]       = currentKey.split("-").map(Number);
  const today       = new Date();
  const isCurrentM  = currentKey === today.toISOString().slice(0,7);
  const firstDay    = new Date(y,m-1,1).getDay() || 7;
  const daysInMonth = new Date(y,m,0).getDate();
  const { start, end } = getPeriodBounds(currentKey);
  const isLocked    = DATA[currentKey].locked;

  for(let i=1;i<firstDay;i++) cal.appendChild(document.createElement("div"));

  // R√©cup√©rer les jours point√©s
  const todayKey  = today.toISOString().slice(0,10);
  const punches   = GEO_PUNCHES_DATA;

  for(let d=1; d<=daysInMonth; d++){
    const dateKey = `${y}-${String(m).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    const div     = document.createElement("div");
    div.className = "day";
    const date    = new Date(y,m-1,d);
    if(date > end) div.classList.add("after-closing");
    if(isLocked)   div.classList.add("locked");
    if(isCurrentM && d===today.getDate()){
      div.classList.add("today");
      div.id = "todayCell";
    }
    const val      = DATA[currentKey].days[d];
    const hasPunch = punches[dateKey]?.length > 0;
    div.innerHTML = `
      <b>${d}</b><br>
      ${val ? val.toFixed(2)+" h" : ""}
      ${hasPunch ? '<span style="font-size:10px;color:var(--geo-active)">üìç</span>' : ""}
    `;
    div.onclick = () => {
      if(isLocked){ alert("üîí Mois verrouill√© (paie valid√©e)"); return; }
      openHours(d);
    };
    cal.appendChild(div);
  }
}

/* =======================
   POPUP HEURES MANUELLES
======================= */
function openHours(d){
  currentDay = d;
  const c = document.getElementById("hoursChoices");
  c.innerHTML = "";
  [0.25,0.5,0.75,1,1.25,1.5,2].forEach(v => {
    const b = document.createElement("button");
    b.textContent = "+"+v+" h";
    b.onclick = () => applyHours(v);
    c.appendChild(b);
  });
  document.getElementById("hoursModal").classList.add("open");
}
function closeHours(){ document.getElementById("hoursModal").classList.remove("open"); }

function applyHours(h){
  if(h<=0) return;
  DATA[currentKey].days[currentDay] = (DATA[currentKey].days[currentDay]||0)+h;
  save(); renderCalendar(); recalc(); closeHours();
}

function confirmManual(){
  const input = document.getElementById("manualHours");
  const h = parseFloat(input.value);
  if(isNaN(h)||h<=0){ alert("‚õî Valeur invalide"); return; }
  applyHours(h);
  input.value = "";
}

function deleteDayHours(){
  if(DATA[currentKey].locked){ alert("üîí Mois verrouill√©"); return; }
  if(!currentDay||!DATA[currentKey].days[currentDay]){ alert("‚ÑπÔ∏è Aucune heure √† supprimer"); return; }
  if(!confirm(`Supprimer toutes les heures du ${currentDay} ?`)) return;
  delete DATA[currentKey].days[currentDay];
  currentDay = null;
  save(); renderCalendar(); recalc(); closeHours();
}

/* =======================
   CALCUL
======================= */
function getPreviousCarry(monthKey){
  const allMonths = [];
  Object.values(ALL_DATA).forEach(yd => {
    if(!yd||typeof yd!=="object") return;
    Object.keys(yd).forEach(key => {
      if(/^\d{4}-\d{2}$/.test(key)) allMonths.push({ key, month:yd[key] });
    });
  });
  allMonths.sort((a,b)=>a.key.localeCompare(b.key));
  let prev = 0;
  for(const item of allMonths){
    if(item.key===monthKey) break;
    if(item.month.carry!=null) prev = item.month.carry;
  }
  return prev;
}

function recalc(){
  const { start, end } = getPeriodBounds(currentKey);
  const weeks = {};
  Object.entries(DATA).forEach(([monthKey, month]) => {
    Object.entries(month.days||{}).forEach(([d,h]) => {
      const date = new Date(monthKey.split("-")[0], monthKey.split("-")[1]-1, d);
      if(date<start||date>end) return;
      const monday = new Date(date);
      const day = monday.getDay()||7;
      monday.setDate(monday.getDate()-day+1);
      const wk = monday.getFullYear()+"-"+String(monday.getMonth()+1).padStart(2,"0")+"-"+String(monday.getDate()).padStart(2,"0");
      weeks[wk] = (weeks[wk]||0)+h;
    });
  });
  let total25=0, total50=0, periodHours=0;
  Object.values(weeks).forEach(wh => {
    periodHours += wh;
    total25     += Math.min(8,wh);
    total50     += Math.max(0,wh-8);
  });
  document.getElementById("hours25").textContent    = total25.toFixed(2);
  document.getElementById("hours50").textContent    = total50.toFixed(2);
  document.getElementById("totalMonth").textContent = periodHours.toFixed(2);
  const prevCarry = getPreviousCarry(currentKey);
  document.getElementById("prevCarry").textContent  = prevCarry.toFixed(2);
  document.getElementById("carryOver").textContent  = (DATA[currentKey]?.carry||0).toFixed(2);
  if(unlocked) calcEuro();
}

function recalcCascade(){
  const allMonths = [];
  Object.values(ALL_DATA).forEach(yd => {
    if(!yd||typeof yd!=="object") return;
    Object.entries(yd).forEach(([key,month]) => {
      if(/^\d{4}-\d{2}$/.test(key)) allMonths.push({ key,month });
    });
  });
  allMonths.sort((a,b)=>a.key.localeCompare(b.key));
  let runningCarry = 0;
  allMonths.forEach(({key}) => {
    const { start,end } = getPeriodBounds(key);
    let periodHours = 0;
    Object.entries(ALL_DATA).forEach(([year,yd]) => {
      Object.entries(yd||{}).forEach(([mk,month]) => {
        Object.entries(month.days||{}).forEach(([d,h]) => {
          const [y,m] = mk.split("-").map(Number);
          const date  = new Date(y,m-1,d);
          if(date>=start&&date<=end) periodHours+=h;
        });
      });
    });
    const month = ALL_DATA[key.slice(0,4)][key];
    const paid  = Number(month.paid)||0;
    runningCarry += periodHours - paid;
    if(runningCarry<0) runningCarry=0;
    month.carry = runningCarry;
  });
}

function calcEuro(){
  if(!unlocked) return;
  const rate    = Number(document.getElementById("rate").value)||0;
  const coef25  = Number(document.getElementById("coef25").value)||1.25;
  const coef50  = Number(document.getElementById("coef50").value)||1.50;
  const netCoef = Number(document.getElementById("coefNet").value)||1;
  const h25 = Number(document.getElementById("hours25").textContent)||0;
  const h50 = Number(document.getElementById("hours50").textContent)||0;
  const w25 = h25*coef25, w50 = h50*coef50;
  const net = (w25+w50)*rate*netCoef;
  document.getElementById("euroResult").textContent  = net.toFixed(2)+" ‚Ç¨";
  document.getElementById("euroDetail").innerHTML    = `
    ${h25.toFixed(2)} h √ó ${coef25} = ${w25.toFixed(2)} h<br>
    ${h50.toFixed(2)} h √ó ${coef50} = ${w50.toFixed(2)} h<br>
    <b>Total pond√©r√© : ${(w25+w50).toFixed(2)} h</b><br>
    √ó ${rate} ‚Ç¨ √ó ${netCoef}
  `;
}

/* =======================
   SAUVEGARDE
======================= */
function save(){
  localStorage.setItem(`${STORAGE_PREFIX}_AUTO_SAVE_DATE`, Date.now());
  recalcCascade();
  Object.entries(ALL_DATA).forEach(([year,yd]) => saveYearData(year,yd));
  updateSaveBadge();
}

function updateSaveBadge(){
  const el  = document.querySelector(".badge.ok");
  if(!el) return;
  const raw = localStorage.getItem(`${STORAGE_PREFIX}_AUTO_SAVE_DATE`);
  const stamp = Number(raw);
  el.textContent = (!stamp||isNaN(stamp))
    ? "üü¢ Sauvegarde locale auto"
    : "üü¢ Sauvegarde locale : "+new Date(stamp).toLocaleString();
}

function registerYear(year){
  let index = JSON.parse(localStorage.getItem(kIndex())||"[]");
  if(!index.includes(year)){ index.push(year); index.sort(); localStorage.setItem(kIndex(),JSON.stringify(index)); }
}
function loadYearData(year){ return JSON.parse(localStorage.getItem(kData(year))||"{}"); }
function saveYearData(year,data){ localStorage.setItem(kData(year),JSON.stringify(data)); }

/* =======================
   ==========================================
   G√âOLOCALISATION ‚Äì LOGIQUE COMPL√àTE
   ==========================================
======================= */

/**
 * Calcule la distance en m√®tres entre deux coordonn√©es GPS (formule Haversine).
 */
function haversine(lat1, lon1, lat2, lon2){
  const R  = 6371000; // rayon Terre en m√®tres
  const œÜ1 = lat1 * Math.PI/180;
  const œÜ2 = lat2 * Math.PI/180;
  const ŒîœÜ = (lat2-lat1) * Math.PI/180;
  const ŒîŒª = (lon2-lon1) * Math.PI/180;
  const a  = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/**
 * Retourne la cl√© date locale (YYYY-MM-DD) du jour.
 */
function todayKey(){
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,"0")}-${String(now.getDate()).padStart(2,"0")}`;
}

// Pas de fen√™tre horaire : la notification se d√©clenche √† toute heure

/**
 * Charge la config g√©o depuis localStorage et met √† jour l'UI.
 */
function loadGeoConfig(){
  GEO_CONFIG = JSON.parse(localStorage.getItem(GEO_KEY)||"{}");

  // Remplir les inputs
  if(GEO_CONFIG.radius)     document.getElementById("geoRadius").value     = GEO_CONFIG.radius;
  if(GEO_CONFIG.watchEnabled) document.getElementById("geoWatchToggle").checked = true;

  updateGeoLocationLabel();
  updatePunchBtn();
  renderGeoTimeline();

  // Reprendre la surveillance si elle √©tait active
  if(GEO_CONFIG.watchEnabled && GEO_CONFIG.lat){
    startGeoWatch();
  }
}

/**
 * Met √† jour le libell√© du lieu enregistr√©.
 */
function updateGeoLocationLabel(){
  const el = document.getElementById("geoSavedLocation");
  if(!el) return;
  if(GEO_CONFIG.lat && GEO_CONFIG.lng){
    el.textContent = `üìç ${GEO_CONFIG.lat.toFixed(5)}, ${GEO_CONFIG.lng.toFixed(5)} (enregistr√© le ${GEO_CONFIG.savedAt||"‚Äî"})`;
    el.style.color = "var(--geo-active)";
  } else {
    el.textContent = "Aucun lieu enregistr√©";
    el.style.color = "var(--muted)";
  }
}

/**
 * Capture la position actuelle comme lieu de travail.
 */
function captureWorkLocation(){
  if(!navigator.geolocation){
    alert("‚ùå La g√©olocalisation n'est pas disponible sur cet appareil");
    return;
  }
  navigator.geolocation.getCurrentPosition(
    pos => {
      GEO_CONFIG.lat     = pos.coords.latitude;
      GEO_CONFIG.lng     = pos.coords.longitude;
      GEO_CONFIG.savedAt = new Date().toLocaleString();
      saveGeoConfig();
      updateGeoLocationLabel();
      alert(`‚úÖ Lieu de travail enregistr√© !\n${GEO_CONFIG.lat.toFixed(5)}, ${GEO_CONFIG.lng.toFixed(5)}`);
    },
    err => {
      alert("‚ùå Impossible de r√©cup√©rer ta position :\n"+geoErrorMsg(err));
    },
    { enableHighAccuracy:true, timeout:10000 }
  );
}

/**
 * Supprime le lieu de travail.
 */
function clearWorkLocation(){
  if(!confirm("Supprimer le lieu de travail enregistr√© ?")) return;
  delete GEO_CONFIG.lat;
  delete GEO_CONFIG.lng;
  delete GEO_CONFIG.savedAt;
  stopGeoWatch();
  saveGeoConfig();
  updateGeoLocationLabel();
  setGeoStatusUI(false);
  document.getElementById("geoDistanceBlock").style.display = "none";
}

/**
 * Enregistre la config et red√©marre la surveillance si n√©cessaire.
 */
function saveGeoConfig(){
  GEO_CONFIG.radius       = Number(document.getElementById("geoRadius").value)||200;
  GEO_CONFIG.watchEnabled = document.getElementById("geoWatchToggle").checked;
  localStorage.setItem(GEO_KEY, JSON.stringify(GEO_CONFIG));

  if(GEO_CONFIG.watchEnabled && GEO_CONFIG.lat){
    startGeoWatch();
    showGeoFeedback("‚úÖ Surveillance activ√©e");
  } else {
    stopGeoWatch();
    showGeoFeedback("‚ÑπÔ∏è Surveillance d√©sactiv√©e");
  }
}

/**
 * D√©marre la surveillance de position.
 */
function startGeoWatch(){
  if(!navigator.geolocation || !GEO_CONFIG.lat) return;
  stopGeoWatch(); // √©vite les doublons

  setGeoStatusUI(true);

  // watchPosition natif (le plus pr√©cis)
  geoWatchId = navigator.geolocation.watchPosition(
    onGeoPosition,
    err => {
      console.warn("‚ö†Ô∏è G√©o erreur:", err.message);
      // Fallback polling si watchPosition √©choue
      if(!geoCheckInterval){
        geoCheckInterval = setInterval(pollGeoPosition, 30000);
      }
    },
    { enableHighAccuracy:true, maximumAge:15000, timeout:20000 }
  );

  // Polling de s√©curit√© toutes les 30s
  if(!geoCheckInterval){
    geoCheckInterval = setInterval(pollGeoPosition, 30000);
  }
}

/**
 * Arr√™te la surveillance.
 */
function stopGeoWatch(){
  if(geoWatchId !== null){
    navigator.geolocation.clearWatch(geoWatchId);
    geoWatchId = null;
  }
  if(geoCheckInterval){
    clearInterval(geoCheckInterval);
    geoCheckInterval = null;
  }
  setGeoStatusUI(false);
}

/**
 * R√©cup√®re la position en mode polling (fallback).
 */
function pollGeoPosition(){
  if(!navigator.geolocation||!GEO_CONFIG.lat) return;
  navigator.geolocation.getCurrentPosition(
    onGeoPosition,
    err => console.warn("üì° G√©o poll erreur:", err.message),
    { enableHighAccuracy:false, timeout:8000 }
  );
}

/**
 * Callback principal : traite une position re√ßue.
 */
function onGeoPosition(pos){
  if(!GEO_CONFIG.lat) return;

  const dist = haversine(
    pos.coords.latitude, pos.coords.longitude,
    GEO_CONFIG.lat, GEO_CONFIG.lng
  );

  geoLastDistance = dist;
  const radius    = GEO_CONFIG.radius || 200;
  const isNear    = dist <= radius;

  updateDistanceBadge(dist, isNear);

  // D√©terminer l'action √† proposer
  if(isNear && !geoIsPunchedIn){
    // Arriv√©e dans la zone
    proposeGeoAction("in", dist);
  } else if(!isNear && geoIsPunchedIn){
    // Sortie de la zone
    proposeGeoAction("out", dist);
  }
}

/**
 * Propose une action via le toast (non bloquant).
 */
let geoActionCooldown = false; // √©vite de spammer le toast

function proposeGeoAction(type, dist){
  if(geoToastPending || geoActionCooldown) return;

  geoToastPending  = type;
  geoActionCooldown = true;

  // Cooldown 3 minutes
  setTimeout(() => { geoActionCooldown = false; }, 3*60*1000);

  const toast = document.getElementById("geoToast");
  const title = document.getElementById("geoToastTitle");
  const msg   = document.getElementById("geoToastMsg");
  const btn   = document.getElementById("geoToastConfirm");

  if(type === "in"){
    title.textContent     = "üìç Tu arrives au travail";
    msg.textContent       = `√Ä ${Math.round(dist)} m du lieu de travail ‚Äì D√©marrer le pointage ?`;
    btn.textContent       = "‚ñ∂ Pointer l'arriv√©e";
    btn.style.background  = "var(--geo-active)";
  } else {
    title.textContent     = "üèÅ Tu quittes le travail";
    msg.textContent       = `Tu t'√©loignes (${Math.round(dist)} m) ‚Äì Enregistrer la sortie ?`;
    btn.textContent       = "‚èπ Pointer la sortie";
    btn.style.background  = "#ff6b6b";
  }

  toast.classList.add("show");

  // Auto-dismiss apr√®s 20 secondes
  if(geoToastTimer) clearTimeout(geoToastTimer);
  geoToastTimer = setTimeout(dismissGeoToast, 20000);
}

/**
 * L'utilisateur confirme l'action propos√©e.
 */
function confirmGeoAction(){
  if(!geoToastPending) return;
  recordPunch(geoToastPending);
  dismissGeoToast();
}

/**
 * Ferme le toast sans action.
 */
function dismissGeoToast(){
  geoToastPending = null;
  if(geoToastTimer){ clearTimeout(geoToastTimer); geoToastTimer=null; }
  document.getElementById("geoToast").classList.remove("show");
}

/**
 * Enregistre un pointage (arriv√©e ou d√©part) avec timestamp.
 */
function recordPunch(type){
  const key   = todayKey();
  const ts    = new Date().toISOString();
  const punches = GEO_PUNCHES_DATA[key] || [];

  punches.push({ type, ts });
  GEO_PUNCHES_DATA[key] = punches;
  localStorage.setItem(GEO_PUNCHES, JSON.stringify(GEO_PUNCHES_DATA));

  geoIsPunchedIn = (type === "in");
  updatePunchBtn();
  renderGeoTimeline();
  computeAndApplyGeoHours(key);
  renderCalendar(); // rafra√Æchit les indicateurs üìç
  showGeoFeedback(type==="in" ? "‚úÖ Arriv√©e point√©e" : "‚úÖ Sortie point√©e");
}

/**
 * Pointage manuel depuis le bouton principal.
 */
function manualPunch(){
  const type = geoIsPunchedIn ? "out" : "in";
  recordPunch(type);
}

/**
 * Calcule les heures travaill√©es depuis les paires in/out du jour
 * et les applique dans le jour courant.
 */
function computeAndApplyGeoHours(key){
  const punches = GEO_PUNCHES_DATA[key] || [];
  let totalMin  = 0;
  let lastIn    = null;

  punches.forEach(p => {
    if(p.type==="in"){
      lastIn = new Date(p.ts);
    } else if(p.type==="out" && lastIn){
      totalMin += (new Date(p.ts) - lastIn) / 60000;
      lastIn = null;
    }
  });

  // Paire en cours non ferm√©e : on ne compte pas encore
  const MIN_MINUTES = 15; // seuil minimum ‚Äì en dessous √ßa ne compte pas
  const totalH = totalMin >= MIN_MINUTES
    ? Math.floor(totalMin / 15) * 0.25  // arrondi au quart d'heure INF√âRIEUR
    : 0;

  // Extraire le mois et le jour
  const [y, m, d] = key.split("-").map(Number);
  const mk = `${y}-${String(m).padStart(2,"0")}`;

  // S'assurer que la structure existe
  if(!ALL_DATA[String(y)]) ALL_DATA[String(y)] = {};
  if(!ALL_DATA[String(y)][mk]) ALL_DATA[String(y)][mk] = { days:{}, paid:0, carry:0, closing:getLastSunday(y,m-1), locked:false };

  // On NE pose pas les heures automatiquement dans le calendrier :
  // l'utilisateur voit la timeline et valide lui-m√™me via le bouton d√©di√©.
  // On affiche simplement le total calcul√© dans la g√©o-card.
  const summaryEl = document.getElementById("geoTodaySummary");
  const hoursEl   = document.getElementById("geoTodayHours");
  if(summaryEl && hoursEl){
    if(totalH > 0){
      hoursEl.textContent     = totalH.toFixed(2)+" h";
      summaryEl.style.display = "block";
      summaryEl.style.color   = "var(--muted)";
    } else if(totalMin > 0 && totalMin < 15){
      hoursEl.textContent     = "< 15 min ‚Äî non comptabilis√©";
      summaryEl.style.display = "block";
      summaryEl.style.color   = "#ff9500";
    } else {
      summaryEl.style.display = "none";
    }
  }
}

/**
 * Applique les heures g√©o du jour dans le calendrier (action volontaire).
 */
function applyGeoHoursToCalendar(){
  const key = todayKey();
  const [y, m, d] = key.split("-").map(Number);
  const mk = `${y}-${String(m).padStart(2,"0")}`;

  if(!ALL_DATA[String(y)]?.[mk]) return;

  const punches = GEO_PUNCHES_DATA[key] || [];
  let totalMin  = 0, lastIn = null;

  punches.forEach(p => {
    if(p.type==="in") lastIn = new Date(p.ts);
    else if(p.type==="out" && lastIn){ totalMin += (new Date(p.ts)-lastIn)/60000; lastIn=null; }
  });

  const MIN_MINUTES = 15;
  if(totalMin > 0 && totalMin < MIN_MINUTES){
    alert("‚ö†Ô∏è Session trop courte ("+Math.round(totalMin)+" min)\nLe minimum est 15 minutes pour √™tre comptabilis√©.");
    return;
  }
  const totalH = Math.floor(totalMin/15)*0.25;
  if(totalH<=0){ alert("‚ö†Ô∏è Aucune heure compl√®te √† reporter (pointage de sortie manquant ?)"); return; }

  ALL_DATA[String(y)][mk].days[d] = totalH;
  DATA = ALL_DATA[String(y)];
  save(); renderCalendar(); recalc();
  showGeoFeedback(`‚úÖ ${totalH.toFixed(2)} h report√©es dans le calendrier`);
}

/**
 * Affiche la timeline des pointages du jour dans la carte g√©o.
 */
function renderGeoTimeline(){
  const timeline = document.getElementById("punchTimeline");
  if(!timeline) return;

  const key     = todayKey();
  const punches = GEO_PUNCHES_DATA[key] || [];

  if(punches.length === 0){
    timeline.innerHTML = `<div style="font-size:12px;color:var(--muted);padding:8px 0">Aucun pointage aujourd'hui</div>`;
    updatePunchBtn();
    return;
  }

  let lastIn = null, html = "";
  let totalMin = 0;

  punches.forEach(p => {
    const t = new Date(p.ts);
    const fmt = t.toLocaleTimeString("fr-FR",{hour:"2-digit",minute:"2-digit"});
    if(p.type==="in"){
      lastIn = t;
      html += `<div class="punch-entry in">‚ñ∂ Arriv√©e <span class="punch-hours">${fmt}</span></div>`;
    } else {
      if(lastIn) totalMin += (t-lastIn)/60000;
      lastIn = null;
      html += `<div class="punch-entry out">‚èπ D√©part  <span class="punch-hours">${fmt}</span></div>`;
    }
  });

  if(totalMin > 0){
    const h = Math.floor(totalMin/60);
    const m = Math.round(totalMin%60);
    const valid = totalMin >= 15;
    html += `<div style="font-size:12px;color:${valid?"var(--geo-active)":"#ff9500"};margin-top:6px;padding:4px 0">
      ${valid
        ? "‚è± Total valid√© : <b>"+h+"h"+(m>0?m+"min":"")+"</b>"
        : "‚ö†Ô∏è "+Math.round(totalMin)+" min ‚Äì minimum 15 min requis"}
    </div>`;
  }

  // Bouton "Reporter dans le calendrier"
  if(punches.some(p=>p.type==="out")){
    html += `<button onclick="applyGeoHoursToCalendar()" style="
      background:#1b3a2a;
      color:var(--geo-active);
      border:1px solid var(--geo-active);
      font-size:13px;
      margin-top:8px
    ">üì• Reporter les heures dans le calendrier</button>`;
  }

  // Bouton r√©initialiser pointages du jour
  html += `<button class="secondary" onclick="clearTodayPunches()" style="font-size:12px;margin-top:6px">
    üóëÔ∏è R√©initialiser les pointages du jour
  </button>`;

  timeline.innerHTML = html;

  // Mettre √† jour √©tat punchedIn
  const lastPunch = punches[punches.length-1];
  geoIsPunchedIn  = lastPunch?.type === "in";
  updatePunchBtn();
  computeAndApplyGeoHours(key);
}

/**
 * R√©initialise les pointages du jour en cours.
 */
function clearTodayPunches(){
  if(!confirm("Supprimer tous les pointages d'aujourd'hui ?")) return;
  delete GEO_PUNCHES_DATA[todayKey()];
  localStorage.setItem(GEO_PUNCHES, JSON.stringify(GEO_PUNCHES_DATA));
  geoIsPunchedIn = false;
  renderGeoTimeline();
  renderCalendar();
  document.getElementById("geoTodaySummary").style.display = "none";
  showGeoFeedback("üóëÔ∏è Pointages supprim√©s");
}

/**
 * Met √† jour le bouton pointage principal selon l'√©tat.
 */
function updatePunchBtn(){
  const btn = document.getElementById("punchBtn");
  if(!btn) return;
  if(geoIsPunchedIn){
    btn.textContent = "‚èπ Pointer la sortie";
    btn.className   = "punch-btn stop";
  } else {
    btn.textContent = "‚ñ∂ Pointer l'arriv√©e";
    btn.className   = "punch-btn start";
  }
}

/**
 * Met √† jour le badge de distance en temps r√©el.
 */
function updateDistanceBadge(dist, isNear){
  const block = document.getElementById("geoDistanceBlock");
  const badge = document.getElementById("geoDistanceBadge");
  if(!block||!badge) return;
  block.style.display = "block";
  const d = dist < 1000 ? Math.round(dist)+"m" : (dist/1000).toFixed(1)+"km";
  badge.textContent = isNear ? `üìç Sur place ‚Äì ${d}` : `üì° √Ä ${d} du lieu`;
  badge.className   = "geo-distance-badge " + (isNear ? "near" : "far");
}

/**
 * Met √† jour l'UI de statut g√©o (point lumineux, labels).
 */
function setGeoStatusUI(active){
  const dot    = document.getElementById("geoDot");
  const label  = document.getElementById("geoStatusLabel");
  const radar  = document.getElementById("geoRadar");
  const card   = document.getElementById("geoCard");
  if(!dot) return;
  dot.className    = "geo-status-dot" + (active?" active":"");
  label.textContent = active ? "üü¢ Surveillance active" : "Inactif";
  if(radar) radar.className = "geo-radar" + (active?" visible":"");
  if(card)  card.classList.toggle("pointed-in", geoIsPunchedIn);
}

/**
 * Affiche un message de feedback court (toast l√©ger).
 */
function showGeoFeedback(msg){
  const el = document.createElement("div");
  el.style.cssText = `
    position:fixed;bottom:20px;left:50%;transform:translateX(-50%);
    background:#1c1f26;border:1px solid #2a3040;color:var(--text);
    padding:10px 18px;border-radius:20px;font-size:13px;z-index:9998;
    transition:opacity .4s;pointer-events:none;
  `;
  el.textContent = msg;
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.opacity="0"; setTimeout(()=>el.remove(),400); },2000);
}

/**
 * Message d'erreur g√©olocalisation.
 */
function geoErrorMsg(err){
  if(err.code===1) return "Permission refus√©e. Autorise la localisation dans les r√©glages.";
  if(err.code===2) return "Position indisponible. V√©rifie le GPS.";
  if(err.code===3) return "D√©lai d√©pass√©. R√©essaie dans un endroit d√©gag√©.";
  return err.message;
}

/**
 * Bascule l'affichage du panneau de config.
 */
function toggleGeoConfig(){
  const p = document.getElementById("geoConfigPanel");
  p.style.display = p.style.display==="none" ? "block" : "none";
}

/* =======================
   S√âCURIT√â ‚Äì CODE EURO
======================= */
async function sha256(str){
  const buf  = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest("SHA-256",buf);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function getSecureCode(){
  let h = localStorage.getItem(kCode());
  if(!h){ h = await sha256("1234"); localStorage.setItem(kCode(),h); }
  return h;
}
async function unlockEuro(){
  const input = document.getElementById("unlockCode").value;
  const ih    = await sha256(input);
  if(ih === await getSecureCode()){
    unlocked = true;
    document.getElementById("euroBox").classList.remove("blur");
    document.getElementById("unlockCode").value = "";
    recalc();
    if(input==="1234") alert("‚ö†Ô∏è Pense √† changer le code par d√©faut");
  } else {
    alert("‚ùå Code incorrect");
  }
}
function toggleChangeCode(){
  if(!unlocked){ alert("üîí D√©verrouille d'abord la zone ‚Ç¨"); return; }
  const box = document.getElementById("changeCodeBox");
  box.style.display = box.style.display==="none" ? "block" : "none";
}
async function changeCode(){
  const old  = document.getElementById("oldCode").value;
  const nw   = document.getElementById("newCode").value;
  const conf = document.getElementById("confirmCode").value;
  if(await sha256(old) !== await getSecureCode()){ alert("‚ùå Ancien code incorrect"); return; }
  if(nw.length<4){ alert("‚õî Code trop court (4 chiffres min)"); return; }
  if(nw!==conf){ alert("‚ùå Les deux nouveaux codes ne correspondent pas"); return; }
  localStorage.setItem(kCode(), await sha256(nw));
  alert("‚úÖ Code modifi√©");
  document.getElementById("changeCodeBox").style.display="none";
}

/* =======================
   EXPORT / IMPORT
======================= */
function prepareExport(){
  createSnapshot("before_export",true);
  recalcCascade();
  saveYearData(getYearFromMonth(currentKey), ALL_DATA[getYearFromMonth(currentKey)]);
}

function exportJSON(){
  prepareExport();
  const year    = getYearFromMonth(currentKey);
  const payload = {
    exportedAt: new Date().toISOString(),
    year, appVersion:APP_VERSION, dataVersion:DATA_VERSION,
    DATA, SETTINGS,
    GEO_PUNCHES: GEO_PUNCHES_DATA // ‚úÖ export des pointages aussi
  };
  const blob = new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
  const a    = document.createElement("a");
  a.href     = URL.createObjectURL(blob);
  a.download = "heures_sup_backup_"+Date.now()+".json";
  a.click();
  document.getElementById("fileDate").textContent = new Date().toLocaleDateString();
}

function importJSONFile(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    createSnapshot("before_import");
    let payload;
    try{ payload=JSON.parse(reader.result); }
    catch{ alert("‚ùå Fichier JSON invalide"); return; }
    if(typeof payload!=="object"||typeof payload.DATA!=="object"||!payload.year){
      alert("‚ùå Structure du fichier invalide"); return;
    }
    const year = String(payload.year);
    if(!/^\d{4}$/.test(year)){ alert("‚ùå Ann√©e invalide"); return; }
    registerYear(year);
    const existing = loadYearData(year);
    let imported=0, repaired=0;
    Object.entries(payload.DATA).forEach(([mk,month])=>{
      if(!/^\d{4}-\d{2}$/.test(mk)) return;
      if(!month.days||typeof month.days!=="object"){ month.days={}; repaired++; }
      if(typeof month.paid!=="number") month.paid=0;
      if(typeof month.carry!=="number") month.carry=0;
      if(typeof month.closing!=="number") month.closing=null;
      if(typeof month.locked!=="boolean") month.locked=false;
      existing[mk]=month; imported++;
    });
    saveYearData(year,existing);
    ALL_DATA[year]=existing;
    // Import pointages g√©o si pr√©sents
    if(payload.GEO_PUNCHES && typeof payload.GEO_PUNCHES==="object"){
      Object.assign(GEO_PUNCHES_DATA, payload.GEO_PUNCHES);
      localStorage.setItem(GEO_PUNCHES, JSON.stringify(GEO_PUNCHES_DATA));
    }
    recalcCascade();
    DATA=ALL_DATA[getYearFromMonth(currentKey)];
    loadMonth();
    alert(`‚úÖ Import termin√©\nAnn√©e : ${year}\nMois import√©s : ${imported}${repaired?"\nMois r√©par√©s : "+repaired:""}`);
  };
  reader.readAsText(file);
  e.target.value="";
}
document.getElementById("importFile").addEventListener("change",importJSONFile);

function exportMonthlyPDF(){
  prepareExport();
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF();
  const month = DATA[currentKey];
  const { start,end } = getPeriodBounds(currentKey);
  const paid = month.paid||0;
  const prevCarry = getPreviousCarry(currentKey);
  let yPos=15;
  pdf.setFontSize(14);
  pdf.text("R√©capitulatif mensuel ‚Äì Heures suppl√©mentaires",10,yPos); yPos+=8;
  pdf.setFontSize(11);
  pdf.text(`P√©riode comptable : ${formatDate(start)} ‚Üí ${formatDate(end)}`,10,yPos); yPos+=10;
  pdf.text(`Report pr√©c√©dent : ${prevCarry.toFixed(2)} h`,10,yPos); yPos+=6;
  pdf.text(`Heures p√©riode : ${document.getElementById("totalMonth").textContent} h`,10,yPos); yPos+=6;
  pdf.text(`Heures pay√©es : ${paid.toFixed(2)} h`,10,yPos); yPos+=6;
  pdf.text(`Reliquat final : ${(month.carry||0).toFixed(2)} h`,10,yPos); yPos+=12;

  // Pointages g√©o du mois
  const key = todayKey();
  const punches = GEO_PUNCHES_DATA[key]||[];
  if(punches.length>0){
    pdf.setFontSize(11); pdf.text("Pointages g√©olocalis√©s du jour :",10,yPos); yPos+=6;
    pdf.setFontSize(9);
    punches.forEach(p=>{
      const t=new Date(p.ts).toLocaleTimeString("fr-FR",{hour:"2-digit",minute:"2-digit"});
      pdf.text(`${p.type==="in"?"‚ñ∂":"‚èπ"} ${t}`,12,yPos); yPos+=5;
    });
    yPos+=4;
  }

  pdf.setFontSize(9);
  pdf.text("Document personnel ‚Äì valeurs indicatives ‚Äì ne constitue pas un bulletin de paie",10,yPos);
  pdf.save(`heures_mensuelles_${currentKey}.pdf`);
}

function exportAnnualPDF(){
  prepareExport();
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF();
  const mths = Object.keys(DATA).filter(k=>/^\d{4}-\d{2}$/.test(k)).sort();
  let yPos=15;
  pdf.setFontSize(14); pdf.text("Bilan annuel ‚Äì Heures suppl√©mentaires",10,yPos); yPos+=10;
  pdf.setFontSize(10);
  pdf.text("Mois",10,yPos); pdf.text("Carry fin",80,yPos); yPos+=6;
  mths.forEach(key=>{ const m=DATA[key]; pdf.text(key,10,yPos); pdf.text((m.carry||0).toFixed(2)+" h",80,yPos); yPos+=6; });
  pdf.save(`bilan_annuel_heures_sup_${mths[0]?.slice(0,4)||""}.pdf`);
}

function formatDate(d){ return d.toLocaleDateString("fr-FR"); }

/* =======================
   SNAPSHOTS / R√âCUP√âRATION
======================= */
function createSnapshot(reason="auto",force=false){
  try{
    if(!force){
      const last=Number(localStorage.getItem("SNAP_LAST")||0);
      if(Date.now()-last<60000) return;
    }
    localStorage.setItem("SNAP_LAST",Date.now());
    const snaps=JSON.parse(localStorage.getItem(SNAP_KEY)||"[]");
    snaps.unshift({ date:new Date().toISOString(),reason,currentKey,DATA:JSON.parse(JSON.stringify(ALL_DATA)),SETTINGS });
    snaps.splice(SNAP_LIMIT);
    localStorage.setItem(SNAP_KEY,JSON.stringify(snaps));
  }catch(e){ console.warn("‚ö†Ô∏è Snapshot √©chou√©",e); }
}
function openRecovery(){
  document.getElementById("recoveryModal").classList.add("open");
  renderSnapshots();
}
function recoverAuto(){
  attemptAutoRecovery();
  localStorage.removeItem("CA_HS_RECOVERY_MODE");
  alert("‚úÖ R√©paration effectu√©e. L'application va red√©marrer.");
  location.reload();
}
function recoverSoftReset(){ localStorage.removeItem("CA_HS_RECOVERY_MODE"); location.reload(); }
function recoverFactory(){
  createSnapshot("factory_reset",true);
  if(!confirm("‚ö†Ô∏è Supprimer TOUTES les donn√©es locales ?")) return;
  Object.keys(localStorage).filter(k=>k.startsWith(STORAGE_PREFIX)).forEach(k=>localStorage.removeItem(k));
  location.reload();
}
function restoreSnapshot(index){
  const snaps=JSON.parse(localStorage.getItem(SNAP_KEY)||"[]");
  if(!snaps[index]){ alert("‚ùå Snapshot introuvable"); return; }
  const snap=snaps[index];
  if(!confirm(`Restaurer l'√©tat du ${new Date(snap.date).toLocaleString()} ?`)) return;
  ALL_DATA=snap.DATA; SETTINGS=snap.SETTINGS||{};
  Object.entries(ALL_DATA).forEach(([year,data])=>saveYearData(year,data));
  localStorage.setItem(kSettings(),JSON.stringify(SETTINGS));
  localStorage.removeItem("CA_HS_RECOVERY_MODE");
  location.reload();
}
function attemptAutoRecovery(){
  let repaired=false;
  try{
    const index=JSON.parse(localStorage.getItem(kIndex())||"[]");
    index.forEach(year=>{
      let data;
      try{ data=loadYearData(year); }
      catch(e){ localStorage.removeItem(kData(year)); repaired=true; return; }
      Object.entries(data).forEach(([mk,month])=>{
        if(!month.days) month.days={};
        if(typeof month.paid!=="number") month.paid=0;
        if(typeof month.carry!=="number") month.carry=0;
        const [y,m]=mk.split("-").map(Number);
        if(!month.closing||new Date(y,m-1,month.closing).getDay()!==0){
          month.closing=getLastSunday(y,m-1); repaired=true;
        }
      });
      saveYearData(year,data);
    });
  }catch(e){ return false; }
  return repaired;
}
function renderSnapshots(){
  const list=document.getElementById("snapshotList");
  if(!list) return;
  const snaps=JSON.parse(localStorage.getItem(SNAP_KEY)||"[]");
  list.innerHTML=snaps.length
    ? snaps.map((s,i)=>`<button onclick="restoreSnapshot(${i})">üì∏ ${new Date(s.date).toLocaleString()} ‚Äì ${s.reason}</button>`).join("")
    : "<p style='font-size:12px;color:#aaa'>Aucun snapshot</p>";
}

/* =======================
   MODALES UI
======================= */
function acceptLegal(){ localStorage.setItem("LEGAL_OK","1"); document.getElementById("legalModal").classList.remove("open"); }
function closeOnboarding(){ localStorage.setItem("ONBOARDING_DONE","1"); document.getElementById("onboardingModal").classList.remove("open"); }
function openTutorial(){ document.getElementById("tutorialModal").classList.add("open"); }
function closeTutorial(){ document.getElementById("tutorialModal").classList.remove("open"); }

/* =======================
   PARAM√àTRES ‚Ç¨
======================= */
["rate","coef25","coef50","coefNet"].forEach(id=>{
  const defaults={rate:10,coef25:1.25,coef50:1.50,coefNet:0.93};
  const input=document.getElementById(id);
  input.value=SETTINGS[id]??defaults[id];
  input.oninput=()=>{ SETTINGS[id]=parseFloat(input.value)||0; localStorage.setItem(kSettings(),JSON.stringify(SETTINGS)); recalc(); };
});

/* =======================
   ANTI-CRASH
======================= */
function safe(fn){
  return function(...args){
    try{ return fn.apply(this,args); }
    catch(e){ handleFatalError({type:"SAFE_FN",message:e.message,stack:e.stack}); }
  };
}
window.onerror=(msg,src,l,c,err)=>{ handleFatalError({type:"JS_ERROR",message:msg,stack:err?.stack}); return true; };
window.addEventListener("unhandledrejection",e=>{
  handleFatalError({type:"PROMISE_REJECTION",message:e.reason?.message||String(e.reason),stack:e.reason?.stack});
});
function handleFatalError(err){
  console.error("üí•",err);
  localStorage.setItem("CA_HS_RECOVERY_MODE","1");
  if(document.getElementById("crashOverlay")) return;
  const o=document.createElement("div");
  o.id="crashOverlay";
  o.style="position:fixed;inset:0;background:#0f1115;color:#fff;z-index:99999;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:20px;text-align:center";
  o.innerHTML=`<h2>‚ö†Ô∏è Une erreur est survenue</h2><p style="opacity:.8;font-size:14px">L'application a rencontr√© un probl√®me inattendu.<br>Aucune donn√©e n'a √©t√© supprim√©e.</p>
    <button onclick="location.reload()" style="margin-top:15px;padding:12px 20px;border-radius:8px;border:none;background:#4f8cff;color:white;font-size:15px">üîÑ Recharger</button>`;
  document.body.appendChild(o);
}

recalc        = safe(recalc);
renderCalendar= safe(renderCalendar);
loadMonth     = safe(loadMonth);
save          = safe(save);

/* =======================
   DEBUG
======================= */
function simulateCrash(){ handleFatalError({type:"SIMULATED_CRASH",message:"Crash simul√©"}); }
function closeDebugGate(){ document.getElementById("debugGate").classList.remove("open"); }
function validateDebugAccess(){
  const input=document.getElementById("debugCode").value;
  if(input!=="1234"){ alert("‚ùå Code incorrect"); return; }
  alert("üß™ Test de crash requis.");
  localStorage.setItem("CA_DEBUG","1");
  simulateCrash();
}
window.addEventListener("DOMContentLoaded",()=>{
  const dbg=document.getElementById("debugTrigger");
  if(dbg) dbg.addEventListener("click",()=>document.getElementById("debugGate").classList.add("open"));
});
(function enableDebugIfNeeded(){
  if(localStorage.getItem("CA_DEBUG")==="1"){
    document.querySelectorAll(".debug-only").forEach(el=>el.style.display="block");
  }
})();

function goMenu(){ localStorage.removeItem("lastApp"); window.location.href="../menu.html"; }

/* =======================
   D√âMARRAGE
======================= */
loadMonth();
</script>

</body>
</html>
